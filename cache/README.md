# Кэширование

Кэширование — высокоуровневое хранение вычисленных данных, для быстрого повторного их доступа. Плюс кэширование сокращает расходы и повышает скорость получение информации. Кэш может содержать статику, запросы в БД, сложные вычесления, запросы и ответы. Есть 2 типа кэширование — серверный и браузерный.

### Определения
- `ttl` — время жизни кэша

## LRU (Least Recently Used)
Данный метод работает, если, например, данных копится в кэше много, но у нас есть только ограниченное кол-во места. Тогда мы будем удалять из кэша данные, которые использовались реже всего, а вместо них будет записывать новые.

## Методика дублирования ключей
В этом методе мы кэшируем запрос в основной ключ с временем жизни N(например 1 час) и создаем дополнительный ключ с временем жизни N+M(например 1 час + 20 секунд). В момент когда пользователь хочет получить данные, если в основном ключе кэш удален, а в дополнительном еще жив, то в основной мы складываем значение из дополнительного ключа, что бы вызовы других пользователей, которые идут паралельно брали значение из кэша. Потом выполняет запрос в БД обновляем кэш и в основном ключе и в дополнительном. В итоге получается что мы выполняли запрос 1 раз, а другие вызовы брали значение из кэша, а последующие вызовы будут брать обновленный кэш.

```js
// Проверяем что в основном кэше ничего нет
if (!cache.get('users')) {
    // Складываем из дополнительного кэша в основной данные
    cache.set('users', cache.get('users_backup'), 60*60)

    // Получаем данные
    result = await promise.getUsers()

    // Закидываем данные в кэш
    cache.set('users', result, 60*60)
    cache.set('users_backup', result, 60*60)
}
```

## Кэширование в браузере

Кэширование статики происходит с помощью заголовков `Cache-Control` и `Expiries`, которые говорят нужно ли браузеру кэшировать статику и когда ему нужно обновить кэш. Бразуре хранит кэш URL'ами, поэтому при смене URL до статики браузер не сможет взять её из кэша.

### Заголовки `Cache-Control`
* `no-cache` — Проверяет актуальность файла на сервере по маркеру (ETag) и при изменениях скачивает его в ином случае скачивание не происходит.
* `no-store` — не будет кэшироваться нигде и каждый раз заново скачиваться
* `public` — значит, что запрос публичный и может схраняться ак в браузере так и в промежуточных местах
* `private` — значит, что запрос приватный и может сохраняться только у клиента в браузере
* `max-age` — указывает время жизни кэша в секундах

### Решение проблемы
* Браузер изначально все запросы отправляет в кэш на проверку пригодности, если он там что-то находит, то он считывает это из кэша.
* Добавлять к файлам статики какой-нибудь хэш, например `script.x345fgdd.js` и при новом билде менять его имя на другое `script.x123fass.js`, тогда браузер будет скачивать новый файл, даже если он закэширован на долгое время, потому что путь до ресурса изменился. 

## Полезные ссылки
* [Кэширование данных](https://ruhighload.com/Кэширование+данных)
* [HTTP-Кэширование](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=ru)
* [Тяжелое кэширование](https://ruhighload.com/Тяжелое+кэширование)
* https://habr.com/ru/company/zerotech/blog/316316/
* https://habr.com/ru/post/129623/
* [Кэширование статики и cache-control](https://ruhighload.com/%D0%9A%D1%8D%D1%88%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5+%D1%81%D1%82%D0%B0%D1%82%D0%B8%D0%BA%D0%B8+%D0%B8+cache-control)
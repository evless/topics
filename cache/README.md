# Кэширование

### Определения
- `ttl` — время жизни кэша

## LRU (Least Recently Used)
Данный метод работает, если, например, данных копится в кэше много, но у нас есть только ограниченное кол-во места. Тогда мы будем удалять из кэша данные, которые использовались реже всего, а вместо них будет записывать новые.

## Методика дублирования ключей
В этом методе мы кэшируем запрос в основной ключ с временем жизни N(например 1 час) и создаем дополнительный ключ с временем жизни N+M(например 1 час + 20 секунд). В момент когда пользователь хочет получить данные, если в основном ключе кэш удален, а в дополнительном еще жив, то в основной мы складываем значение из дополнительного ключа, что бы вызовы других пользователей, которые идут паралельно брали значение из кэша. Потом выполняет запрос в БД обновляем кэш и в основном ключе и в дополнительном. В итоге получается что мы выполняли запрос 1 раз, а другие вызовы брали значение из кэша, а последующие вызовы будут брать обновленный кэш.

```js
// Проверяем что в основном кэше ничего нет
if (!cache.get('users')) {
    // Складываем из дополнительного кэша в основной данные
    cache.set('users', cache.get('users_backup'), 60*60)

    // Получаем данные
    result = await promise.getUsers()

    // Закидываем данные в кэш
    cache.set('users', result, 60*60)
    cache.set('users_backup', result, 60*60)
}
```

## Кэширование в браузере
### Заголовки `Cache-Control`
* `no-cache` — Проверяет актуальность файла на сервере по маркеру (ETag) и при изменениях скачивает его в ином случае скачивание не происходит.
* `no-store` — не будет кэшироваться нигде и каждый раз заново скачиваться
* `public` — значит, что запрос публичный и может схраняться ак в браузере так и в промежуточных местах
* `private` — значит, что запрос приватный и может сохраняться только у клиента в браузере
* `max-age` — указывает время жизни кэша в секундах

### Решение проблемы
* Браузер изначально все запросы отправляет в кэш на проверку пригодности, если он там что-то находит, то он считывает это из кэша.
* Добавлять к файлам статики какой-нибудь хэш, например `script.x345fgdd.js` и при новом билде менять его имя на другое `script.x123fass.js`, тогда браузер будет скачивать новый файл, даже если он закэширован на долгое время, потому что путь до ресурса изменился. 

## Полезные ссылки
* [Кэширование данных](https://ruhighload.com/Кэширование+данных)
* [HTTP-Кэширование](https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/http-caching?hl=ru)
* [Тяжелое кэширование](https://ruhighload.com/Тяжелое+кэширование)
* https://habr.com/ru/company/zerotech/blog/316316/
* https://habr.com/ru/post/129623/
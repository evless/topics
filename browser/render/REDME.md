# Рендеринг страницы

## Терминология

* **Движок браузера** — отвечает за взаимодествия UI и визуализацией
* **Сетевой механизм** — исходя из названия отвечает за сетевые операции, такие как HTTP
* **Модуль рендеринга** — отвечает за отображение запрашиваемого контента. К примеру, если запрошенный пользователем контент представлен HTML документом, то данный компонент браузера производит синтаксический разбор HTML и CSS кода, а получаемый в результате этого анализа контент отображает на экране устройства.
* **JS интерпитатор** — можно подробнее почитуть [тут](https://github.com/evless/topics/blob/master/engine/README.md)
* **Хранилище данных** — хранение разных кук и прочих данных, необходим для работы приложения
* **Внутренний UI** — применяется для отрисовки основных графических элементов и виджетов типа комбо-боксов и окон. Он предоставляет типичный, независимый от платформы интерфейс, а на низком уровне использует методы, предусмотренные операционной системой.

## Порядок обработки документа

Сначала браузер собирает все теги и строит из них DOM-tree. Тут же он строит каскадное дерево из CSS. После наложения друг на друга мы получаем renderTree — дерево, уже с конечным результатом, где, например, вырезаются теги, которые имеют `display: none` или не нужно их визуально отображать, например head, scripts. Потом происходит компановка. При этом браузер может по ходу уже начинать отрисовывать элементы, которые дошли до этапа компановки.

**Нужно кэшировать текстуры, что бы браузер брал их из кэша. То есть есть делаем `display: none`, то браузер будет удалять эту текстуру (нужно погуглить про этот момент)**

1. Парсинг HTML — преобразует исходный код в синтаксическое дерево с помощью словаря описанного в W3C
1. Парсинг CSS — преобразует исходный код в синтаксическое дерево
1. DOM tree [Дерево всех тегов документа] — получаем после парсинга HTML
1. CSSSOM tree — Получаем после парсинга CSS
1. Дерево отображение (Render Tree) — Дерево всех элементов, которые мы должны отобразить пользователю. Получается мы сюда не включаем разные теги типа `head`, `script`, которые имеют `display: none`, но элементы с аттрибутом `hidden` входят в состав этого дерева
1. Компановка (layout) — тут происходит рассчет всех элементов и определения их размеров и цветов, что бы расположить потом на доску.
1. Отрисовка — Вывод каждого объекта на экран

## Порядок добавления блочных элементов в стек
1. Цвет фона
1. Фоновое изображение
1. Рамка
1. Дочерние объекты
1. Внешние границы

## Система "грязных битов"
Чтобы не выполнять перекомпоновку при каждом изменении, браузеры используют так называемую систему "грязных битов". Измененный объект отображения и его дочерние элементы помечаются как "грязные", то есть требующие перекомпоновки.

Используется два флага: dirty и children are dirty. Флаг children are dirty означает, что перекомпоновка требуется не самому объекту отображения, а одному или нескольким из его дочерних объектов.

## Полезные ссылки:
* [Критический путь рендеринга веб-страниц](https://habr.com/ru/post/262239/)
* [Отрисовка в браузере и рекомендации по веб-производительности](https://www.cat-in-web.ru/otrisovka-v-brauzere-i-rekomendatsii-po-veb-proizvoditelnosti/)
* [Принципы работы современных веб-браузеров](https://www.html5rocks.com/ru/tutorials/internals/howbrowserswork/)
* **Почему не стоит использовать GIF** — https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/replace-animated-gifs-with-video/
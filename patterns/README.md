# Паттерны

## Основные тезисы
- Есть 3 вида паттернов: *Пораждающие* (создание новых объектов [*Factory*, *Module*]), *структурные* (упорядочивают объекты [*Decorator*, *Facade*]) и *паттерны поведения*(как объекты соотносятся друг с другом [*Observer*, *Command*]).
- Паттерны делятся на те, которые применяются к классу или те, которые применяются к объекту.
- Не нужно изобретать велосипед (ленивый программист => хороший программист)
- Эти шаблоны проходят сквозь все языки программирования

## Используемые в JS паттерны
- *Decorator* — Добавляет новую функциональность объектам (например connect)
- *Module (модуль)* — Нужен для инкапсуляции данных/методов (IIFE обертки)
- *Factory*
- *Constructor* — Создает новый объекты в их собственной области видимости
- *Singleton*
- *Facade* — Используется для создания упрощенного интерфейса (например jQuery)
- *Observer* — пользоваляет следить за изменением объектам и оповещать об этих изменениях
- *Command* — инкапсулирует вызов метода в один объект

## Используемые на проекте паттерны
- *Decorator* — не уверен
- *Observer* — при взаимодействии с одним виджетом на борде у нас могут поменяться другие. При изменении окна браузера мы перестраиваем элементы
- *Factory* — Каждый виджет создается на основе фабрики
- *Command* — Управление настройкой дашборда, чтобы можно было откатить изменения или вернуть обратно (Но это пока еще не реализовано)

## Паттерны в функциональном программировании
*bracket*
*Reader*
*State*
*Middleware*
*Pipeline*
*Strategy*
*Token*

## Список паттернов
- *Abstract Factory (абстрактная фабрика)* — Предоставляет интерфейс для создания семейств, связанных между собой, или независимых объектов, конкретные классы которых неизвестны.
- *Adapter (адаптер)* — Преобразует интерфейс класса в некоторый другой интерфейс, ожидаемый клиентами. Обеспечивает совместную работу классов, которая была бы невозможна без данного паттерна изза несовместимости интерфейсов.
- *Bridge (мост)* — Отделяет абстракцию от реализации, благодаря чему появляется возможность ность независимо изменять то и другое.
- *Builder (строитель)* — Отделяет конструирование сложного объекта от его представления, позволяя использовать один и тот же процесс конструирования для создания различных представлений.
- *Chain of Responsibility (цепочка обязанностей)* — Можно избежать жесткой зависимости отправителя запроса от его получателя, при этом запросом начинает обрабатываться один из нескольких объектов. Объектыполучатели связываются в цепочку, и запрос передается по цепочке, пока какой-то объект его не обработает.
- *Command (команда)* — Инкапсулирует запрос в виде объекта, позволяя тем самым параметризовывать клиентов типом запроса, устанавливать очередность запросов, протоколировать их и поддерживать отмену выполнения операций.
- *Composite (компоновщик)* — Группирует объекты в древовидные структуры для представления иерархий типа «частьцелое». Позволяет клиентам работать с единичными объектами так же, как с группами объектов.
- *Decorator (декоратор)* — Динамически возлагает на объект новые функции. Декораторы применяются для расширения имеющейся функциональности и являются гибкой альтернативой порождению подклассов.
- *Facade (фасад)* — Предоставляет унифицированный интерфейс к множеству интерфейсов в некоторой подсистеме. Определяет интерфейс более высокого уровня, облегчающий работу с подсистемой.
- *Factory Method (фабричный метод)* — Определяет интерфейс для создания объектов, при этом выбранный класс инстанцируется подклассами.
- *Flyweight (приспособленец)* — Использует разделение для эффективной поддержки большого числа мелких объектов.
- *Interpreter (интерпретатор)* — Для заданного языка определяет представление его грамматики, а также интерпретатор предложений языка, использующий это представление.
- *Iterator (итератор)* — Дает возможность последовательно обойти все элементы составного объекта, не раскрывая его внутреннего представления.
- *Mediator (посредник)* — Определяет объект, в котором инкапсулировано знание о том, как взаимодействуют объекты из некоторого множества. Способствует уменьшению числа связей между объектами, позволяя им работать без явных ссылок друг на друга. Это, в свою очередь, дает возможность независимо изменять схему взаимодействия.
- *Memento (хранитель)* — Позволяет, не нарушая инкапсуляции, получить и сохранить во внешней памяти внутреннее состояние объекта, чтобы позже объект можно было восстановить точно в таком же состоянии.
- *Observer (наблюдатель)* — Определяет между объектами зависимость типа одинкомногим, так что при изменении состоянии одного объекта все зависящие от него получают извещение и автоматически обновляются.
- *Prototype (прототип)* — Описывает виды создаваемых объектов с помощью прототипа и создает новые объекты путем его копирования.
- *Proxy (заместитель)* — Подменяет другой объект для контроля доступа к нему.
- *Singleton (одиночка)* — Гарантирует, что некоторый класс может иметь только один экземпляр, и предоставляет глобальную точку доступа к нему.
- *State (состояние)* — Позволяет объекту варьировать свое поведение при изменении внутреннего состояния. При этом создается впечатление, что поменялся класс объекта.
- *Strategy (стратегия)* — Определяет семейство алгоритмов, инкапсулируя их все и позволяя подставлять один вместо другого. Можно менять алгоритм независимо от клиента, который им пользуется.
- *Template Method (шаблонный метод)* — Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.
- *Visitor (посетитель)* — Представляет операцию, которую надо выполнить над элементами объекта. Позволяет определить новую операцию, не меняя классы элементов, к которым он применяется.

## Полезные ссылки
- [Learning JavaScript Design Patterns](https://addyosmani.com/resources/essentialjsdesignpatterns/book/#singletonpatternjavascript)
- [Шаблоны проектирования в JavaScript](https://medium.com/@marina.kovalyova/java-script-design-patterns-569c627d25f9)